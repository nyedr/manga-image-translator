import io
import os
import secrets
import shutil
import signal
import subprocess
import sys
from argparse import Namespace
import asyncio

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))


from fastapi import FastAPI, Request, HTTPException, Header, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, HTMLResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from pathlib import Path

from manga_translator import Config
from server.instance import ExecutorInstance, executor_instances
from server.myqueue import task_queue
from server.request_extraction import get_ctx, while_streaming, TranslateRequest, BatchTranslateRequest, get_batch_ctx
from server.to_json import to_translation, TranslationResponse

app = FastAPI()
nonce = None

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 添加result文件夹静态文件服务
if os.path.exists("../result"):
    app.mount("/result", StaticFiles(directory="../result"), name="result")


@app.post("/register", response_description="no response", tags=["internal-api"])
async def register_instance(instance: ExecutorInstance, req: Request, req_nonce: str = Header(alias="X-Nonce")):
    if req_nonce != nonce:
        raise HTTPException(401, detail="Invalid nonce")
    instance.ip = req.client.host
    executor_instances.register(instance)


def transform_to_image(ctx):
    img_byte_arr = io.BytesIO()
    ctx.result.save(img_byte_arr, format="PNG")
    return img_byte_arr.getvalue()


def transform_to_json(ctx):
    return to_translation(ctx).model_dump_json().encode("utf-8")


def transform_to_bytes(ctx):
    return to_translation(ctx).to_bytes()


@app.post("/translate/json", response_model=TranslationResponse, tags=["api", "json"], response_description="json strucure inspired by the ichigo translator extension")
async def json(req: Request, data: TranslateRequest):
    ctx = await get_ctx(req, data.config, data.image)
    return to_translation(ctx)


@app.post("/translate/bytes", response_class=StreamingResponse, tags=["api", "json"], response_description="custom byte structure for decoding look at examples in 'examples/response.*'")
async def bytes(req: Request, data: TranslateRequest):
    ctx = await get_ctx(req, data.config, data.image)
    return StreamingResponse(content=to_translation(ctx).to_bytes())


@app.post("/translate/image", response_description="the result image", tags=["api", "json"], response_class=StreamingResponse)
async def image(req: Request, data: TranslateRequest) -> StreamingResponse:
    ctx = await get_ctx(req, data.config, data.image)
    img_byte_arr = io.BytesIO()
    ctx.result.save(img_byte_arr, format="PNG")
    img_byte_arr.seek(0)

    return StreamingResponse(img_byte_arr, media_type="image/png")


@app.post("/translate/json/stream", response_class=StreamingResponse, tags=["api", "json"], response_description="A stream over elements with strucure(1byte status, 4 byte size, n byte data) status code are 0,1,2,3,4 0 is result data, 1 is progress report, 2 is error, 3 is waiting queue position, 4 is waiting for translator instance")
async def stream_json(req: Request, data: TranslateRequest) -> StreamingResponse:
    return await while_streaming(req, transform_to_json, data.config, data.image)


@app.post("/translate/bytes/stream", response_class=StreamingResponse, tags=["api", "json"], response_description="A stream over elements with strucure(1byte status, 4 byte size, n byte data) status code are 0,1,2,3,4 0 is result data, 1 is progress report, 2 is error, 3 is waiting queue position, 4 is waiting for translator instance")
async def stream_bytes(req: Request, data: TranslateRequest) -> StreamingResponse:
    return await while_streaming(req, transform_to_bytes, data.config, data.image)


@app.post("/translate/image/stream", response_class=StreamingResponse, tags=["api", "json"], response_description="A stream over elements with strucure(1byte status, 4 byte size, n byte data) status code are 0,1,2,3,4 0 is result data, 1 is progress report, 2 is error, 3 is waiting queue position, 4 is waiting for translator instance")
async def stream_image(req: Request, data: TranslateRequest) -> StreamingResponse:
    return await while_streaming(req, transform_to_image, data.config, data.image)


@app.post("/translate/with-form/json", response_model=TranslationResponse, tags=["api", "form"], response_description="json strucure inspired by the ichigo translator extension")
async def json_form(req: Request, image: UploadFile = File(...), config: str = Form("{}")):
    img = await image.read()
    conf = Config.parse_raw(config)
    if image.filename:
        conf._image_name = os.path.splitext(image.filename)[0]
    ctx = await get_ctx(req, conf, img)
    return to_translation(ctx)


@app.post("/translate/with-form/bytes", response_class=StreamingResponse, tags=["api", "form"], response_description="custom byte structure for decoding look at examples in 'examples/response.*'")
async def bytes_form(req: Request, image: UploadFile = File(...), config: str = Form("{}")):
    img = await image.read()
    conf = Config.parse_raw(config)
    if image.filename:
        conf._image_name = os.path.splitext(image.filename)[0]
    ctx = await get_ctx(req, conf, img)
    return StreamingResponse(content=to_translation(ctx).to_bytes())


@app.post("/translate/with-form/image", response_description="the result image", tags=["api", "form"], response_class=StreamingResponse)
async def image_form(req: Request, image: UploadFile = File(...), config: str = Form("{}")) -> StreamingResponse:
    img = await image.read()
    conf = Config.parse_raw(config)
    if image.filename:
        conf._image_name = os.path.splitext(image.filename)[0]
    ctx = await get_ctx(req, conf, img)
    img_byte_arr = io.BytesIO()
    ctx.result.save(img_byte_arr, format="PNG")
    img_byte_arr.seek(0)

    return StreamingResponse(img_byte_arr, media_type="image/png")


@app.post("/translate/with-form/json/stream", response_class=StreamingResponse, tags=["api", "form"], response_description="A stream over elements with strucure(1byte status, 4 byte size, n byte data) status code are 0,1,2,3,4 0 is result data, 1 is progress report, 2 is error, 3 is waiting queue position, 4 is waiting for translator instance")
async def stream_json_form(req: Request, image: UploadFile = File(...), config: str = Form("{}")) -> StreamingResponse:
    img = await image.read()
    conf = Config.parse_raw(config)
    if image.filename:
        conf._image_name = os.path.splitext(image.filename)[0]
    return await while_streaming(req, transform_to_json, conf, img)


@app.post("/translate/with-form/bytes/stream", response_class=StreamingResponse, tags=["api", "form"], response_description="A stream over elements with strucure(1byte status, 4 byte size, n byte data) status code are 0,1,2,3,4 0 is result data, 1 is progress report, 2 is error, 3 is waiting queue position, 4 is waiting for translator instance")
async def stream_bytes_form(req: Request, image: UploadFile = File(...), config: str = Form("{}")) -> StreamingResponse:
    img = await image.read()
    conf = Config.parse_raw(config)
    if image.filename:
        conf._image_name = os.path.splitext(image.filename)[0]
    return await while_streaming(req, transform_to_bytes, conf, img)


@app.post("/translate/with-form/image/stream", response_class=StreamingResponse, tags=["api", "form"], response_description="A stream over elements with strucure(1byte status, 4 byte size, n byte data) status code are 0,1,2,3,4 0 is result data, 1 is progress report, 2 is error, 3 is waiting queue position, 4 is waiting for translator instance")
async def stream_image_form(req: Request, image: UploadFile = File(...), config: str = Form("{}")) -> StreamingResponse:
    img = await image.read()
    conf = Config.parse_raw(config)
    if image.filename:
        conf._image_name = os.path.splitext(image.filename)[0]
    return await while_streaming(req, transform_to_image, conf, img)


@app.post("/queue-size", response_model=int, tags=["api", "json"])
async def queue_size() -> int:
    return len(task_queue.queue)


@app.api_route("/latest-result", methods=["GET", "HEAD"], tags=["api", "file"])
async def get_latest_result(session_id: str = None):
    """获取最新的翻译结果图片，通过会话ID精确查找"""
    result_dir = "../result"
    if not os.path.exists(result_dir):
        raise HTTPException(404, detail="Result directory not found")

    latest_path = None

    # 增加带超时的轮询逻辑
    max_retries = 100
    for attempt in range(max_retries):
        found_dirs = []
        matching_dirs = []
        latest_time = 0
        current_latest_path = None

        if os.path.exists(result_dir):
            for item in os.listdir(result_dir):
                item_path = os.path.join(result_dir, item)
                if os.path.isdir(item_path):
                    found_dirs.append(item)
                    final_png_path = os.path.join(item_path, "final.png")

                    if os.path.exists(final_png_path):
                        is_matching = True
                        if session_id:
                            is_matching = session_id in item
                            if is_matching:
                                matching_dirs.append(item)

                        if is_matching:
                            mtime = os.path.getmtime(final_png_path)
                            if mtime > latest_time:
                                latest_time = mtime
                                current_latest_path = final_png_path

        if current_latest_path:
            latest_path = current_latest_path
            break

        if attempt < max_retries - 1:
            await asyncio.sleep(0.3)

    if latest_path:
        async def file_iterator():
            with open(latest_path, "rb") as f:
                yield f.read()

        return StreamingResponse(
            file_iterator(),
            media_type="image/png",
            headers={"Content-Disposition": f"inline; filename={os.path.basename(latest_path)}"}
        )
    else:
        error_detail = "No result image found. "
        if session_id:
            error_detail += f"No matches for session_id '{session_id}'. "
        raise HTTPException(404, detail=error_detail)


@app.post("/translate/batch/json", response_model=list[TranslationResponse], tags=["api", "json", "batch"])
async def batch_json(req: Request, data: BatchTranslateRequest):
    """Batch translate images and return JSON format results"""
    results = await get_batch_ctx(req, data.config, data.images, data.batch_size)
    return [to_translation(ctx) for ctx in results]


@app.post("/translate/batch/images", response_description="Zip file containing translated images", tags=["api", "batch"])
async def batch_images(req: Request, data: BatchTranslateRequest):
    """Batch translate images and return zip archive containing translated images"""
    import zipfile
    import tempfile

    results = await get_batch_ctx(req, data.config, data.images, data.batch_size)

    # Create temporary ZIP file
    with tempfile.NamedTemporaryFile(delete=False, suffix='.zip') as tmp_file:
        with zipfile.ZipFile(tmp_file, 'w') as zip_file:
            for i, ctx in enumerate(results):
                if ctx.result:
                    img_byte_arr = io.BytesIO()
                    ctx.result.save(img_byte_arr, format="PNG")
                    zip_file.writestr(f"translated_{i + 1}.png", img_byte_arr.getvalue())

        # Return ZIP file
        with open(tmp_file.name, 'rb') as f:
            zip_data = f.read()

        # Clean up temporary file
        os.unlink(tmp_file.name)

        return StreamingResponse(
            io.BytesIO(zip_data),
            media_type="application/zip",
            headers={"Content-Disposition": "attachment; filename=translated_images.zip"}
        )


@app.get("/", response_class=HTMLResponse, tags=["ui"])
async def index() -> HTMLResponse:
    script_directory = Path(__file__).parent
    html_file = script_directory / "index.html"
    html_content = html_file.read_text(encoding="utf-8")
    return HTMLResponse(content=html_content)


@app.get("/manual", response_class=HTMLResponse, tags=["ui"])
async def manual():
    script_directory = Path(__file__).parent
    html_file = script_directory / "manual.html"
    html_content = html_file.read_text(encoding="utf-8")
    return HTMLResponse(content=html_content)


def generate_nonce():
    return secrets.token_hex(16)


def start_translator_client_proc(host: str, port: int, nonce: str, params: Namespace):
    cmds = [
        sys.executable,
        '-m', 'manga_translator',
        'shared',
        '--host', host,
        '--port', str(port),
        '--nonce', nonce,
    ]
    if params.use_gpu:
        cmds.append('--use-gpu')
    if params.use_gpu_limited:
        cmds.append('--use-gpu-limited')
    if params.ignore_errors:
        cmds.append('--ignore-errors')
    if params.verbose:
        cmds.append('--verbose')
    if params.models_ttl:
        cmds.append('--models-ttl=%s' % params.models_ttl)
    if params.pre_dict:
        cmds.extend(['--pre-dict', params.pre_dict])
    if params.post_dict:
        cmds.extend(['--post-dict', params.post_dict])
    if params.font_path:
        cmds.extend(['--font-path', params.font_path])
    if params.attempts:
        cmds.extend(['--attempts', str(params.attempts)])
    if params.model_dir:
        cmds.extend(['--model-dir', params.model_dir])
    if params.kernel_size != 3:
        cmds.extend(['--kernel-size', str(params.kernel_size)])
    if params.context_size:
        cmds.extend(['--context-size', str(params.context_size)])
    if params.batch_size != 1:
        cmds.extend(['--batch-size', str(params.batch_size)])
    if params.batch_concurrent:
        cmds.append('--batch-concurrent')
    if params.disable_memory_optimization:
        cmds.append('--disable-memory-optimization')

    # Custom OpenAI configuration parameters
    if params.custom_openai_api_key:
        cmds.extend(['--custom-openai-api-key', params.custom_openai_api_key])
    if params.custom_openai_api_base:
        cmds.extend(['--custom-openai-api-base', params.custom_openai_api_base])
    if params.custom_openai_model:
        cmds.extend(['--custom-openai-model', params.custom_openai_model])
    if params.custom_openai_model_conf:
        cmds.extend(['--custom-openai-model-conf', params.custom_openai_model_conf])

    base_path = os.path.dirname(os.path.abspath(__file__))
    parent = os.path.dirname(base_path)
    proc = subprocess.Popen(cmds, cwd=parent)
    executor_instances.register(ExecutorInstance(ip=host, port=port))

    def handle_exit_signals(signal, frame):
        proc.terminate()
        sys.exit(0)

    signal.signal(signal.SIGINT, handle_exit_signals)
    signal.signal(signal.SIGTERM, handle_exit_signals)

    return proc


def prepare(args):
    global nonce
    if args.nonce is None:
        nonce = os.getenv('MT_WEB_NONCE', generate_nonce())
    else:
        nonce = args.nonce
    if args.start_instance:
        return start_translator_client_proc(args.host, args.port + 1, nonce, args)
    folder_name = "upload-cache"
    if os.path.exists(folder_name):
        shutil.rmtree(folder_name)
    os.makedirs(folder_name)


@app.post("/simple_execute/translate_batch", tags=["internal-api"])
async def simple_execute_batch(req: Request, data: BatchTranslateRequest):
    """Internal batch translation execution endpoint"""
    # Implementation for batch translation logic
    # Currently returns empty results, actual implementation needs to call batch translator
    from manga_translator import MangaTranslator
    translator = MangaTranslator({'batch_size': data.batch_size})

    # Prepare image-config pairs
    images_with_configs = [(img, data.config) for img in data.images]

    # Execute batch translation
    results = await translator.translate_batch(images_with_configs, data.batch_size)

    return results


@app.post("/execute/translate_batch", tags=["internal-api"])
async def execute_batch_stream(req: Request, data: BatchTranslateRequest):
    """Internal batch translation streaming execution endpoint"""
    # Streaming batch translation implementation
    from manga_translator import MangaTranslator
    translator = MangaTranslator({'batch_size': data.batch_size})

    # Prepare image-config pairs
    images_with_configs = [(img, data.config) for img in data.images]

    # Execute batch translation (streaming version requires more complex implementation)
    results = await translator.translate_batch(images_with_configs, data.batch_size)

    return results

# todo: restart if crash
# todo: cache results
# todo: cleanup cache

if __name__ == '__main__':
    import uvicorn
    from args import parse_arguments

    args = parse_arguments()
    args.start_instance = True
    proc = prepare(args)
    print("Nonce: " + nonce)
    try:
        uvicorn.run(app, host=args.host, port=args.port)
    except Exception:
        if proc:
            proc.terminate()
